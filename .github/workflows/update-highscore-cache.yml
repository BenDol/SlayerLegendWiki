name: Update Contributor Highscore Cache

# This workflow automatically updates the contributor highscore cache
# by fetching fresh contributor statistics and storing them in a GitHub issue.
# This prevents every user from hitting the GitHub API for the same data.
#
# The cache is stored in a GitHub issue with the label "highscore-cache"
# and is read by the wiki's highscore page for all users.
#
# Cache Structure:
# - All Time: Total contributions from repos.listContributors()
# - This Month: Commits from the last 30 days
# - This Week: Commits from the last 7 days
#
# All contributor data includes userId for username-change immunity
#
# Schedule: Runs daily at 2 AM UTC
# Manual: Can be triggered manually via GitHub UI (Actions tab)
on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
  workflow_dispatch:  # Allow manual trigger from Actions tab

jobs:
  update-cache:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write  # Need write permission to update cache issue

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update highscore cache
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const CACHE_ISSUE_TITLE = '[Cache] Contributor Highscore';

            // Read wiki config to get the configured branch
            let configuredBranch = 'main'; // default
            try {
              const configPath = path.join(process.env.GITHUB_WORKSPACE, 'wiki-config.json');
              const configContent = fs.readFileSync(configPath, 'utf8');
              const config = JSON.parse(configContent);
              configuredBranch = config?.wiki?.repository?.branch || 'main';
              console.log(`ðŸ“‹ Using configured branch from wiki-config.json: ${configuredBranch}`);
            } catch (error) {
              console.warn('âš ï¸ Failed to read wiki-config.json, using default branch: main');
            }

            console.log('ðŸ” Fetching contributor statistics for all time periods...');

            /**
             * Calculate a fair contributor score that prevents gaming
             * Formula: (contributions * 100) + (quality_bonus * 2)
             *
             * - Base score from contributions (heavily weighted at 100x)
             * - Quality bonus from average lines per contribution (2x weight)
             * - This rewards both volume AND quality, preventing spam contributions
             */
            function calculateContributorScore(contributor) {
              const contributions = contributor.contributions || 0;
              const additions = contributor.additions || 0;
              const deletions = contributor.deletions || 0;

              // Base score: contributions heavily weighted
              const baseScore = contributions * 100;

              // Quality bonus: average lines changed per contribution
              // High value = meaningful contributions, Low value = spam
              const totalLines = additions + deletions;
              const averageLinesPerContribution = contributions > 0 ? totalLines / contributions : 0;
              const qualityBonus = averageLinesPerContribution * 2;

              // Final score
              const score = baseScore + qualityBonus;

              return Math.round(score);
            }

            /**
             * Fetch all-time contributor stats
             * Enhanced with PR data for additions/deletions
             */
            async function fetchAllTimeContributors() {
              console.log('ðŸ“Š Fetching all-time contributors...');

              // Get base contributor counts
              const { data: contributors } = await github.rest.repos.listContributors({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });

              console.log(`âœ… Found ${contributors.length} all-time contributors`);

              // Create map with base stats
              const contributorMap = new Map();
              contributors.forEach(contributor => {
                contributorMap.set(contributor.id, {
                  userId: contributor.id,
                  login: contributor.login,
                  avatarUrl: contributor.avatar_url,
                  contributions: contributor.contributions,
                  additions: 0,
                  deletions: 0,
                  profileUrl: contributor.html_url,
                  prestige: 0,
                  type: contributor.type
                });
              });

              // Enhance with PR data to get additions/deletions
              console.log('ðŸ“Š Fetching all merged PRs for additions/deletions data...');

              let page = 1;
              const perPage = 100;
              let hasMore = true;

              while (hasMore) {
                const { data: prs } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'closed',
                  base: configuredBranch,
                  per_page: perPage,
                  page: page,
                });

                if (prs.length === 0) break;

                // Only process merged PRs
                const mergedPRs = prs.filter(pr => pr.merged_at);
                console.log(`   Page ${page}: ${mergedPRs.length} merged PRs`);

                for (const pr of mergedPRs) {
                  const userId = pr.user?.id;
                  if (userId && contributorMap.has(userId)) {
                    const contributor = contributorMap.get(userId);
                    contributor.additions += pr.additions || 0;
                    contributor.deletions += pr.deletions || 0;
                  }
                }

                hasMore = prs.length === perPage;
                page++;

                // Safety limit to prevent excessive API calls
                if (page > 50) {
                  console.warn('âš ï¸ Reached page limit (50) for PR fetching');
                  break;
                }
              }

              // Convert to array and calculate scores
              const formatted = Array.from(contributorMap.values()).map(contributor => {
                contributor.score = calculateContributorScore(contributor);
                return contributor;
              });

              // Sort by score (descending), fallback to contributions if equal
              formatted.sort((a, b) => {
                if (b.score !== a.score) {
                  return b.score - a.score;
                }
                return b.contributions - a.contributions;
              });

              console.log(`âœ… Enhanced ${formatted.length} contributors with PR data`);

              return formatted;
            }

            /**
             * Fetch merged PRs within a date range and aggregate additions/deletions by author
             * This provides accurate line change statistics for the scoring system
             */
            async function fetchMergedPRsInDateRange(since, until, branch = 'main') {
              console.log(`ðŸ“Š Fetching merged PRs from ${since} to ${until} targeting branch '${branch}'...`);

              const allPRs = [];
              let page = 1;
              const perPage = 100;

              // Fetch all merged PRs (state=closed with merged_at not null)
              while (true) {
                const { data } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'closed',
                  base: branch,
                  sort: 'updated',
                  direction: 'desc',
                  per_page: perPage,
                  page: page,
                });

                if (data.length === 0) break;

                // Filter to only merged PRs within date range
                const mergedPRsInRange = data.filter(pr => {
                  if (!pr.merged_at) return false;
                  const mergedDate = new Date(pr.merged_at);
                  return mergedDate >= new Date(since) && mergedDate <= new Date(until);
                });

                allPRs.push(...mergedPRsInRange);

                // If we got fewer than perPage, we've reached the end
                // Also stop if the last PR is before our start date (optimization)
                if (data.length < perPage) break;
                const lastPRDate = data[data.length - 1].updated_at;
                if (new Date(lastPRDate) < new Date(since)) break;

                page++;
              }

              console.log(`âœ… Found ${allPRs.length} merged PRs in date range`);

              // Aggregate PRs by author (use user ID as key for permanent identification)
              const contributorMap = new Map();

              for (const pr of allPRs) {
                const author = pr.user;
                const login = author?.login;
                const userId = author?.id;

                // Skip PRs without a GitHub user
                if (!login) continue;

                // Use user ID as key (permanent), fallback to login
                const key = userId ? userId.toString() : `legacy:${login}`;

                if (contributorMap.has(key)) {
                  const existing = contributorMap.get(key);
                  existing.contributions++;
                  existing.additions += pr.additions || 0;
                  existing.deletions += pr.deletions || 0;
                  // Update login in case username changed
                  existing.login = login;
                } else {
                  contributorMap.set(key, {
                    userId: userId || null,
                    login: login,
                    avatarUrl: author.avatar_url,
                    contributions: 1,
                    additions: pr.additions || 0,
                    deletions: pr.deletions || 0,
                    profileUrl: author.html_url,
                    prestige: 0,
                    type: author.type || 'User',
                  });
                }
              }

              // Convert to array and calculate scores
              const contributors = Array.from(contributorMap.values()).map(contributor => {
                contributor.score = calculateContributorScore(contributor);
                return contributor;
              });

              // Sort by score (descending), fallback to contributions if equal
              contributors.sort((a, b) => {
                if (b.score !== a.score) {
                  return b.score - a.score;
                }
                return b.contributions - a.contributions;
              });

              console.log(`âœ… Found ${contributors.length} unique contributors from merged PRs`);
              return contributors;
            }

            /**
             * Fetch commits within a date range and aggregate by author
             * @deprecated Use fetchMergedPRsInDateRange for accurate additions/deletions
             */
            async function fetchCommitsInDateRange(since, until, branch = 'main') {
              console.log(`ðŸ“Š Fetching commits from ${since} to ${until} on branch '${branch}'...`);

              const commits = [];
              let page = 1;
              const perPage = 100;

              // Fetch all commits in date range (with pagination)
              // Use sha parameter to explicitly specify the branch
              while (true) {
                const { data } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: branch, // Explicitly specify branch to only count main branch commits
                  since,
                  until,
                  per_page: perPage,
                  page: page,
                });

                if (data.length === 0) break;
                commits.push(...data);

                // If we got fewer than perPage, we've reached the end
                if (data.length < perPage) break;
                page++;
              }

              console.log(`âœ… Found ${commits.length} commits in date range`);

              // Aggregate commits by author (use user ID as key for permanent identification)
              const contributorMap = new Map();

              for (const commit of commits) {
                const author = commit.author || commit.commit.author;
                const login = author?.login;
                const userId = author?.id;

                // Skip commits without a GitHub user (e.g., local git commits)
                if (!login) continue;

                // Use user ID as key (permanent), fallback to login for local commits
                const key = userId ? userId.toString() : `legacy:${login}`;

                if (contributorMap.has(key)) {
                  contributorMap.get(key).contributions++;
                  // Update login in case username changed
                  contributorMap.get(key).login = login;
                } else {
                  contributorMap.set(key, {
                    userId: userId || null,
                    login: login,
                    avatarUrl: author.avatar_url,
                    contributions: 1,
                    additions: 0, // Note: commit data doesn't include line changes
                    deletions: 0, // Note: commit data doesn't include line changes
                    profileUrl: author.html_url,
                    prestige: 0,
                    type: author.type || 'User',
                  });
                }
              }

              // Convert map to array and calculate scores
              const contributors = Array.from(contributorMap.values()).map(contributor => ({
                ...contributor,
                score: calculateContributorScore(contributor),
              }));

              // Sort by score (descending), fallback to contributions if equal
              contributors.sort((a, b) => {
                if (b.score !== a.score) {
                  return b.score - a.score;
                }
                return b.contributions - a.contributions;
              });

              console.log(`âœ… Found ${contributors.length} unique contributors in date range`);
              return contributors;
            }

            // Calculate date ranges
            const now = new Date();
            const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

            // Fetch all three categories in parallel (using merged PR data for accurate stats)
            console.log(`ðŸ”„ Fetching contributor data from branch: ${configuredBranch}`);
            const [allTimeContributors, thisMonthContributors, thisWeekContributors] = await Promise.all([
              fetchAllTimeContributors(),
              fetchMergedPRsInDateRange(oneMonthAgo.toISOString(), now.toISOString(), configuredBranch),
              fetchMergedPRsInDateRange(oneWeekAgo.toISOString(), now.toISOString(), configuredBranch),
            ]);

            // Create cache data with all categories
            const cacheData = {
              lastUpdated: now.toISOString(),
              categories: {
                allTime: {
                  contributors: allTimeContributors,
                },
                thisMonth: {
                  startDate: oneMonthAgo.toISOString(),
                  endDate: now.toISOString(),
                  contributors: thisMonthContributors,
                },
                thisWeek: {
                  startDate: oneWeekAgo.toISOString(),
                  endDate: now.toISOString(),
                  contributors: thisWeekContributors,
                },
              },
            };

            console.log('ðŸ” Looking for cache issue...');

            // Find existing cache issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'highscore-cache',
              per_page: 100
            });

            // Find issue with exact title match
            const existingIssue = issues.find(issue => issue.title === CACHE_ISSUE_TITLE);

            let issueNumber;

            if (existingIssue) {
              // Update existing issue
              issueNumber = existingIssue.number;
              console.log(`ðŸ“ Updating existing cache issue #${issueNumber}...`);

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: JSON.stringify(cacheData, null, 2)
              });
            } else {
              // Create new issue
              console.log('ðŸ“ Creating new cache issue...');

              const { data: newIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: CACHE_ISSUE_TITLE,
                body: JSON.stringify(cacheData, null, 2),
                labels: ['highscore-cache', 'automated']
              });

              issueNumber = newIssue.number;

              // Lock the issue to prevent unwanted comments
              try {
                await github.rest.issues.lock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  lock_reason: 'off-topic'
                });
                console.log('ðŸ”’ Locked cache issue to collaborators only');
              } catch (lockError) {
                console.warn('âš ï¸ Failed to lock issue:', lockError.message);
              }
            }

            console.log(`âœ… Cache updated successfully!`);
            console.log(`   Issue: #${issueNumber}`);
            console.log(`   Last Updated: ${cacheData.lastUpdated}`);
            console.log('');
            console.log('ðŸ“Š Category Statistics:');
            console.log(`   All Time: ${allTimeContributors.length} contributors`);
            console.log(`   This Month: ${thisMonthContributors.length} contributors`);
            console.log(`   This Week: ${thisWeekContributors.length} contributors`);
            console.log('');
            console.log(`ðŸ† Top 3 All Time: ${allTimeContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            if (thisMonthContributors.length > 0) {
              console.log(`ðŸ”¥ Top 3 This Month: ${thisMonthContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            }
            if (thisWeekContributors.length > 0) {
              console.log(`âš¡ Top 3 This Week: ${thisWeekContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            }
